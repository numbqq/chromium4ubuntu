libdav1d 0.9.2 on jammy isn't new enough for Chromium's taste:

  third_party/webrtc/modules/video_coding/codecs/av1/dav1d_decoder.cc:87:5: error: no member named 'n_threads' in 'Dav1dSettings'
    s.n_threads = std::max(2, settings.number_of_cores());
    ~ ^
  third_party/webrtc/modules/video_coding/codecs/av1/dav1d_decoder.cc:88:5: error: no member named 'max_frame_delay' in 'Dav1dSettings'
    s.max_frame_delay = 1;   // For low latency decoding.
    ~ ^

  media/filters/dav1d_video_decoder.cc:201:5: error: no member named 'n_threads' in 'Dav1dSettings'
    s.n_threads = VideoDecoder::GetRecommendedThreadCount(frame_threads *
    ~ ^
  media/filters/dav1d_video_decoder.cc:207:7: error: no member named 'max_frame_delay' in 'Dav1dSettings'
    s.max_frame_delay = 1;
    ~ ^

  error[E0609]: no field `max_frame_delay` on type `dav1d_sys::bindings::Dav1dSettings`
    --> ../../third_party/crabbyavif/src/src/codecs/dav1d.rs:40:18
     |
  40 |         settings.max_frame_delay = 1;
     |                  ^^^^^^^^^^^^^^^ unknown field

  error[E0609]: no field `n_threads` on type `dav1d_sys::bindings::Dav1dSettings`
    --> ../../third_party/crabbyavif/src/src/codecs/dav1d.rs:41:18
     |
  41 |         settings.n_threads = 8;
     |                  ^^^^^^^^^ unknown field

This one is tangential, but we deal with it here anyway:

  error[E0308]: mismatched types
    --> ../../third_party/crabbyavif/src/src/codecs/dav1d.rs:73:17
     |
  70 |             let res = dav1d_data_wrap(
     |                       --------------- arguments to this function are incorrect
  ...
  73 |                 av1_payload.len(),
     |                 ^^^^^^^^^^^^^^^^^ expected `u64`, found `usize`

Fortunately, these are easy to work around.

--- a/third_party/webrtc/modules/video_coding/codecs/av1/dav1d_decoder.cc
+++ b/third_party/webrtc/modules/video_coding/codecs/av1/dav1d_decoder.cc
@@ -84,8 +84,10 @@ bool Dav1dDecoder::Configure(const Setti
   Dav1dSettings s;
   dav1d_default_settings(&s);
 
+#if 0	// XtraDeb fix
   s.n_threads = std::max(2, settings.number_of_cores());
   s.max_frame_delay = 1;   // For low latency decoding.
+#endif
   s.all_layers = 0;        // Don't output a frame for every spatial layer.
   // Limit max frame size to avoid OOM'ing fuzzers. crbug.com/325284120.
   s.frame_size_limit = 16384 * 16384;
--- a/media/filters/dav1d_video_decoder.cc
+++ b/media/filters/dav1d_video_decoder.cc
@@ -200,6 +200,7 @@ void Dav1dVideoDecoder::Initialize(const
   GetDecoderThreadCounts(config.coded_size().height(), &tile_threads,
                          &frame_threads);
 
+#if 0	// XtraDeb fix
   // While dav1d has switched to a thread pool, preserve the same thread counts
   // we used when tile and frame threads were configured distinctly. It may be
   // possible to lower this after some performance analysis of the new system.
@@ -210,6 +211,7 @@ void Dav1dVideoDecoder::Initialize(const
   // require at least two buffers before the first frame can be output.
   if (low_delay || config.is_rtc())
     s.max_frame_delay = 1;
+#endif	// XtraDeb fix
 
   // Only output the highest spatial layer.
   s.all_layers = 0;
--- a/third_party/crabbyavif/src/src/codecs/dav1d.rs
+++ b/third_party/crabbyavif/src/src/codecs/dav1d.rs
@@ -52,8 +52,10 @@ impl Decoder for Dav1d {
         let mut settings_uninit: MaybeUninit<Dav1dSettings> = MaybeUninit::uninit();
         unsafe { dav1d_default_settings(settings_uninit.as_mut_ptr()) };
         let mut settings = unsafe { settings_uninit.assume_init() };
+/* XtraDeb fix
         settings.max_frame_delay = 1;
         settings.n_threads = i32::try_from(config.max_threads).unwrap_or(1);
+*/
         settings.operating_point = config.operating_point as i32;
         settings.all_layers = if config.all_layers { 1 } else { 0 };
 
@@ -84,7 +86,7 @@ impl Decoder for Dav1d {
             let res = dav1d_data_wrap(
                 (&mut data) as *mut _,
                 av1_payload.as_ptr(),
-                av1_payload.len(),
+                av1_payload.len() as size_t,	// XtraDeb fix
                 Some(avif_dav1d_free_callback),
                 /*cookie=*/ std::ptr::null_mut(),
             );
